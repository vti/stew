#!/usr/bin/env perl

use strict;
use warnings;

use JSON ();
use Getopt::Long;
use File::Basename qw(basename);
use CPAN::DistnameInfo;
use Parse::CPAN::Packages::Fast;
use File::Spec;
use HTTP::Tiny;

my $cpan = 'cpan.org';
my $repo;
my $local;
my $cpanfile;
my $stewfile;
GetOptions(
    "cpan=s"     => \$cpan,
    "repo=s"     => \$repo,
    "cpanfile=s" => \$cpanfile,
    "stewfile=s" => \$stewfile,
    "local"      => \$local
) or die("Error in command line arguments\n");

die '--cpan is required' unless $cpan;

$cpan = "http://$cpan" unless $cpan =~ m{^https?://};

my @packages = @ARGV;
if ($cpanfile) {
    require Module::CPANfile;

    my $file    = Module::CPANfile->load($cpanfile);
    my $prereqs = $file->prereqs->merged_requirements->as_string_hash;

    push @packages, keys %$prereqs;
}
die "Usage: [options] <package1> <package2>\n" unless @packages;

my $packages_index = create_packages_index($cpan);

foreach my $package (@packages) {
    print "Working on '$package'...\n";

    my $distribution = resolve_package($package);
    if (!$distribution) {
        warn "Cannot resolve $package\n";
        next;
    }

    next if $distribution->{distribution} eq 'perl';

    if (-f distribution_to_stewfile($distribution)) {
        next;
    }

    print
      "$package -> $distribution->{distribution}-$distribution->{version}\n";

    gen_tree($distribution);
}

my %gen_tree_seen;

sub gen_tree {
    my ($distribution) = @_;

    return if $gen_tree_seen{$distribution->{pathname}}++;

    my $dependencies = distribution_dependencies($distribution);

    foreach my $dependency (@$dependencies) {
        if (-f distribution_to_stewfile($distribution)) {
            next;
        }

        gen_tree($dependency);
    }

    warn
"Generating stewfile for $distribution->{distribution}-$distribution->{version}\n";

    my $ok = gen_stew($distribution, $dependencies);

    if ($ok && $stewfile) {
        open my $fh, '>>', $stewfile or die "Can't open stewfile: $!\n";
        print $fh dist_to_pkg($distribution->{distribution}), "\n";
        close $fh;
    }
}

sub dist_to_pkg {
    my ($dist) = @_;

    my @parts = map { s/_/-/g; $_ } split /-/, $dist;

    return 'lib' . join('-', map { lc } @parts) . '-perl';
}

my %gen_stew_seen;

sub gen_stew {
    my ($distribution, $dependencies) = @_;

    return if $gen_stew_seen{$distribution->{pathname}}++;

    my $pkg     = dist_to_pkg($distribution->{distribution});
    my $version = $distribution->{version};

    my $dist     = $distribution->{distribution};
    my $pathname = $distribution->{pathname};
    my $deps     = join ', ',
      map { "'$_'" } map { dist_to_pkg($_->{distribution}) } @$dependencies;
    $deps = ', ' . $deps if $deps;

    my $file = basename($pathname);
    my ($name) = $file =~ m/^(.*)(?:\.tar.gz|\.tgz)$/;

    my $stew_file = distribution_to_stewfile($distribution);

    print "Generating $stew_file ...\n";

    my $dist_url = "$cpan/authors/id/$pathname";

    if ($local && $repo) {
        my $ua = HTTP::Tiny->new;

        my $local_path = File::Spec->catfile($repo, 'src', basename($pathname));
        print "Mirroring '$dist_url' -> '$local_path'\n";

        my $response = $ua->mirror($dist_url, $local_path);
        die "Failed: $response->{reason}: $response->{content}\n"
          unless $response->{success};
    }

    my $options = '';
    if (!$local) {
        $options = qq{\$url     = "$dist_url";};
    }

    open my $fh, '>', $stew_file or die $!;
    print $fh <<"EOF";
# Auto generated by cpan2stew

\$name    = "$pkg";
\$version = "$version";
\$package = "\$name-\$version";
\@depends = ('perl'$deps);
\$file    = "$file";
$options

prepare {
    "tar xzf '\$file'"
};

build {
    "cd $name",
    "unset PERL5LIB PERL_MM_OPT PERL_MB_OPT PERL_LOCAL_LIB_ROOT",
    "export PERL_MM_USE_DEFAULT=1 MODULEBUILDRC=/dev/null PERL_AUTOINSTALL=--skipdeps",
    "export PERL5LIB=\$ENV{DESTDIR}/\$ENV{PREFIX}/lib/perl5/vendor_perl",
    (-f '$name/Build.PL' ? 'perl Build.PL' : 'perl Makefile.PL'),
    (-f '$name/Build.PL' ? './Build' : 'make')
};

install {
    "cd $name",
    "unset PERL5LIB PERL_MM_OPT PERL_MB_OPT PERL_LOCAL_LIB_ROOT",
    "export PERL5LIB=\$ENV{DESTDIR}/\$ENV{PREFIX}/lib/perl5/vendor_perl",
    (
        -f '$name/Build.PL'
        ? "./Build install --installdirs=vendor --destdir=\$ENV{DESTDIR}"
        : "make install INSTALLDIRS=vendor DESTDIR=\$ENV{DESTDIR}"
    )
};

cleanup {
    "cd \$ENV{DESTDIR}",
    "find . -name 'perllocal.pod' -exec rm -f {} \\\\;",
    "find . -name '.packlist' -exec rm -f {} \\\\;",
    "find . -type d -empty -delete",
};
EOF

    close $fh;

    print "ok\n";

    return 1;
}

sub resolve_package {
    my ($package) = @_;

    my $info = $packages_index->package($package);
    return unless $info;

    return {
        package      => $info->package,
        distribution => $info->distribution->dist,
        version      => $info->distribution->version,
        pathname     => $info->distribution->pathname,
    };
}

sub create_packages_index {
    my ($cpan) = @_;

    my $details_file_url = "$cpan/modules/02packages.details.txt.gz";
    my $details_file     = basename $details_file_url;

    my $ua = HTTP::Tiny->new;

    print "Mirroring '$details_file_url' -> '$details_file'...\n";
    my $response = $ua->mirror($details_file_url, $details_file);

    die "Failed: $response->{reason}: $response->{content}\n"
      unless $response->{success};

    return Parse::CPAN::Packages::Fast->new($details_file);
}

sub distribution_dependencies {
    my ($distribution) = @_;

    my $ua       = HTTP::Tiny->new;
    my $response = $ua->post(
        'http://fastapi.metacpan.org/v1/release/_search',
        {
            content => JSON::encode_json(
                {
                    query  => {match_all => {}},
                    filter => {
                        and => [
                            {
                                term =>
                                  {version => '' . $distribution->{version}}
                            },
                            {
                                term => {
                                    distribution =>
                                      $distribution->{distribution}
                                }
                            }
                        ]
                    },
                    size => 1
                }
            )
        }
    );

    my $result = JSON::decode_json($response->{content});

    my $runtime =
      $result->{hits}->{hits}->[0]->{_source}->{metadata}->{prereqs}->{runtime}
      ->{requires};

    my @dependencies;
    my %dependencies_seen;
    foreach my $dep_name (sort keys %$runtime) {
        my $module = $packages_index->package($dep_name);
        next unless $module;

        my $dist = $module->distribution->dist;

        next if $dist eq 'perl';

        next if $dependencies_seen{$dist}++;

        push @dependencies,
          {
            distribution => $dist,
            pathname     => $module->distribution->pathname,
            version      => $module->distribution->version,
          };
    }

    return \@dependencies;
}

sub distribution_to_stewfile {
    my ($distribution) = @_;

    my $pkg = dist_to_pkg($distribution->{distribution});

    my $stew_file = "${pkg}_$distribution->{version}.stew";

    if ($repo) {
        $stew_file = File::Spec->catfile($repo, 'stew', $stew_file);
    }

    return $stew_file;
}
